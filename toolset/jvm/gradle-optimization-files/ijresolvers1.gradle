//-- Generated by org.jetbrains.kotlin.idea.gradleJava.testing.KotlinTestTasksResolver
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
gradle.taskGraph.whenReady { taskGraph ->
    taskGraph.allTasks.each { task ->
        def taskSuperClass = task.class
        while (taskSuperClass != Object.class) {
            if (taskSuperClass.canonicalName == "org.jetbrains.kotlin.gradle.tasks.KotlinTest") {
                try {
                    KotlinMppTestLogger.logTestReportLocation(task.reports?.html?.entryPoint?.path)
                    KotlinMppTestLogger.configureTestEventLogging(task)
                    task.testLogging.showStandardStreams = false
                }
                catch (all) {
                    logger.error("", all)
                }
                return
            } else {
                taskSuperClass = taskSuperClass.superclass
            }
        }
    }
}
//
//-- Generated by org.jetbrains.kotlin.idea.gradleJava.testing.KotlinTestTasksResolver
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
import groovy.xml.MarkupBuilder
import org.gradle.api.tasks.testing.TestDescriptor
import org.gradle.api.tasks.testing.TestListener
import org.gradle.api.tasks.testing.TestOutputEvent
import org.gradle.api.tasks.testing.TestOutputListener
import org.gradle.api.tasks.testing.TestResult
import org.gradle.api.internal.tasks.testing.TestDescriptorInternal

class KotlinMppTestLogger {
    static def configureTestEventLogging(def task) {
        task.addTestListener(new TestListener() {
            @Override
            void beforeSuite(TestDescriptor descriptor) {
                logTestEvent("beforeSuite", (TestDescriptorInternal)descriptor, null, null)
            }

            @Override
            void afterSuite(TestDescriptor descriptor, TestResult result) {
                logTestEvent("afterSuite", (TestDescriptorInternal)descriptor, null, result)
            }

            @Override
            void beforeTest(TestDescriptor descriptor) {
                logTestEvent("beforeTest", (TestDescriptorInternal)descriptor, null, null)
            }

            @Override
            void afterTest(TestDescriptor descriptor, TestResult result) {
                logTestEvent("afterTest", (TestDescriptorInternal)descriptor, null, result)
            }
        })

        task.addTestOutputListener(new TestOutputListener() {
            @Override
            void onOutput(TestDescriptor descriptor, TestOutputEvent event) {
                logTestEvent("onOutput", (TestDescriptorInternal)descriptor, event, null)
            }
        })
    }

    static def logTestEvent(testEventType, TestDescriptorInternal testDescriptor, testEvent, testResult) {
        def writer = new StringWriter()
        def xml = new MarkupBuilder(writer)
        xml.event(type: testEventType) {
            test(id: testDescriptor.id, parentId: testDescriptor.parent?.id ?: '') {
                if (testDescriptor) {
                    descriptor(
                            name: testDescriptor.name ?: '',
                            displayName: getName(testDescriptor) ?: '',
                            className: testDescriptor.className ?: ''
                    )
                }
                if (testEvent) {
                    def message = escapeCdata(testEvent.message)
                    event(destination: testEvent.destination) {
                        xml.mkp.yieldUnescaped("$message")
                    }
                }
                if (testResult) {
                    def errorMsg = escapeCdata(testResult.exception?.message ?: '')
                    def stackTrace = escapeCdata(getStackTrace(testResult.exception))
                    result(resultType: testResult.resultType ?: '', startTime: testResult.startTime, endTime: testResult.endTime) {
                        def exception = testResult.exception
                        if (exception?.message?.trim()) xml.mkp.yieldUnescaped("<errorMsg>$errorMsg</errorMsg>")
                        if (exception) xml.mkp.yieldUnescaped("<stackTrace>$stackTrace</stackTrace>")

                        if ('kotlin.AssertionError'.equals(exception?.class?.name) || exception instanceof AssertionError) {
                            failureType('assertionFailed')
                            return
                        }

                        failureType('error')
                    }
                }
            }
        }

        writeLog(writer.toString())
    }

    static String escapeCdata(String s) {
        return "<![CDATA[" + s?.getBytes("UTF-8")?.encodeBase64()?.toString() + "]]>";
    }

    static def wrap(String s) {
        if (!s) return s;
        s.replaceAll("\r\n|\n\r|\n|\r", "<ijLogEol/>\n")
    }

    static def writeLog(s) {
        println String.format("\n<ijLog>%s</ijLog>", wrap(s))
    }

    static def logTestReportLocation(def report) {
        if (!report) return
        def writer = new StringWriter()
        def xml = new MarkupBuilder(writer)
        xml.event(type: 'reportLocation', testReport: report)
        writeLog(writer.toString());
    }

    static def logConfigurationError(aTitle, aMessage, boolean openSettings) {
        def writer = new StringWriter()
        def xml = new MarkupBuilder(writer)
        xml.event(type: 'configurationError', openSettings: openSettings) {
            title(aTitle)
            message(aMessage)
        }
        writeLog(writer.toString());
    }

    static def getStackTrace(Throwable t) {
        if (!t) return ''
        StringWriter sw = new StringWriter()
        t.printStackTrace(new PrintWriter(sw))
        sw.toString()
    }

    static def getName(TestDescriptorInternal descriptor) {
        try {
            return descriptor.getDisplayName() // available starting from ver. 4.10.3
        }
        catch (Throwable ignore) {
            return descriptor.getName()
        }
    }
}
//
//-- Generated by org.jetbrains.plugins.gradle.service.project.JavaGradleProjectResolver
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
//file:noinspection GrPackage

import groovy.xml.MarkupBuilder
import org.gradle.api.internal.tasks.testing.TestDescriptorInternal
import org.gradle.api.tasks.testing.TestDescriptor
import org.gradle.api.tasks.testing.TestOutputEvent
import org.gradle.api.tasks.testing.TestResult

class TestEventLogger {

  static def writeLog(String text) {
    println String.format(
      "<ijLog>%s</ijLog>",
      text.replaceAll("\r\n|\n\r|\n|\r", "<ijLogEol/>")
    )
  }

  static void writeLogTestEvent(String testEventType, TestDescriptor testDescriptor, TestOutputEvent testEvent, TestResult testResult) {
    def writer = new StringWriter()
    def xml = new MarkupBuilder(writer)
    logTestEvent(xml, testEventType, testDescriptor, testEvent, testResult)
    writeLog(writer.toString())
  }

  private static def logTestEvent(
    MarkupBuilder xml,
    String testEventType,
    TestDescriptor testDescriptor,
    TestOutputEvent testEvent,
    TestResult testResult
  ) {
    xml.event(type: testEventType) {
      def internalDescriptor = (TestDescriptorInternal)testDescriptor
      def testId = internalDescriptor.id
      def parentTestId = internalDescriptor.parent?.id ?: ''
      xml.test(id: testId, parentId: parentTestId) {
        if (testDescriptor != null) {
          logTestDescriptor(xml, testDescriptor)
        }
        if (testEvent != null) {
          logTestOutputEvent(xml, testEvent)
        }
        if (testResult != null) {
          logTestResult(xml, testResult)
        }
      }
    }
  }

  private static def logTestDescriptor(MarkupBuilder xml, TestDescriptor testDescriptor) {
    def name = testDescriptor.name ?: ''
    def displayName = getName(testDescriptor) ?: ''
    def className = testDescriptor.className ?: ''
    xml.descriptor(name: name, displayName: displayName, className: className)
  }

  private static def logTestOutputEvent(MarkupBuilder xml, TestOutputEvent testEvent) {
    def message = escapeCdata(testEvent.message)
    xml.event(destination: testEvent.destination) {
      xml.mkp.yieldUnescaped("$message")
    }
  }

  private static logTestResult(MarkupBuilder xml, TestResult testResult) {
    xml.result(resultType: testResult.resultType ?: '', startTime: testResult.startTime, endTime: testResult.endTime) {
      def exception = testResult.exception

      if (exception != null) {
        logFailureDescriptor(xml, exception)
      }

      if ('org.junit.ComparisonFailure' == exception?.class?.name) {
        logJunit4ComparisonFailure(xml, exception)
      }
      else if ('junit.framework.ComparisonFailure' == exception?.class?.name) {
        logJunit4ComparisonFailure(xml, exception)
      }
      else if ('org.opentest4j.AssertionFailedError' == exception?.class?.name) {
        logJunit5ComparisonFailure(xml, exception)
      }
      else if ('com.intellij.rt.execution.junit.FileComparisonFailure' == exception?.class?.name) {
        logIjFileComparisonFailure(xml, exception)
      }
      else if ('com.intellij.rt.execution.junit.FileComparisonFailure' == exception?.cause?.class?.name) {
        logIjFileComparisonFailure(xml, exception.cause)
      }
      else if (exception instanceof AssertionError) {
        xml.failureType('assertionFailed')
      }
      else {
        xml.failureType('error')
      }
    }
  }

  private static def logFailureDescriptor(MarkupBuilder xml, Throwable exception) {
    def errorMsg = escapeCdata(exception.message)
    def exceptionName = escapeCdata(exception.class.name)
    def stackTrace = escapeCdata(getStackTrace(exception))

    xml.mkp.yieldUnescaped("<errorMsg>$errorMsg</errorMsg>")
    xml.mkp.yieldUnescaped("<exceptionName>$exceptionName</exceptionName>")
    xml.mkp.yieldUnescaped("<stackTrace>$stackTrace</stackTrace>")
  }

  // org.junit.ComparisonFailure | junit.framework.ComparisonFailure
  private static def logJunit4ComparisonFailure(MarkupBuilder xml, Throwable exception) {
    def expected = escapeCdata(exception.fExpected)
    def actual = escapeCdata(exception.fActual)

    xml.failureType('comparison')
    xml.mkp.yieldUnescaped("<expected>$expected</expected>")
    xml.mkp.yieldUnescaped("<actual>$actual</actual>")
  }

  // org.opentest4j.AssertionFailedError
  private static def logJunit5ComparisonFailure(MarkupBuilder xml, Throwable exception) {
    def expected = escapeCdata(exception.expected?.stringRepresentation)
    def actual = escapeCdata(exception.actual?.stringRepresentation)

    xml.failureType('comparison')
    xml.mkp.yieldUnescaped("<expected>$expected</expected>")
    xml.mkp.yieldUnescaped("<actual>$actual</actual>")
  }

  // com.intellij.rt.execution.junit.FileComparisonFailure
  private static def logIjFileComparisonFailure(MarkupBuilder xml, Throwable exception) {
    def expected = escapeCdata(exception.expected)
    def actual = escapeCdata(exception.actual)
    def filePath = escapeCdata(exception.filePath)
    def actualFilePath = exception.hasProperty('actualFilePath')
      ? escapeCdata(exception.actualFilePath)
      : escapeCdata(null)

    xml.failureType('file-comparison')
    xml.mkp.yieldUnescaped("<expected>$expected</expected>")
    xml.mkp.yieldUnescaped("<actual>$actual</actual>")
    xml.mkp.yieldUnescaped("<filePath>$filePath</filePath>")
    xml.mkp.yieldUnescaped("<actualFilePath>$actualFilePath</actualFilePath>")
  }

  private static String escapeCdata(String s) {
    def string = s ?: ""
    def encodedString = string.getBytes("UTF-8").encodeBase64()
    return "<![CDATA[$encodedString]]>"
  }

  private static def getStackTrace(Throwable t) {
    if (!t) return ''
    StringWriter sw = new StringWriter()
    t.printStackTrace(new PrintWriter(sw))
    sw.toString()
  }

  private static def getName(TestDescriptor descriptor) {
    try {
      // available starting from ver. 4.10.3
      return descriptor.getDisplayName()
    }
    catch (Throwable ignore) {
      return descriptor.getName()
    }
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
//file:noinspection GrPackage

import org.gradle.api.tasks.testing.*

class FileComparisonTestEventLogger {

  static def configureTestEventLogging(def task) {
    task.addTestListener(
      new TestListener() {
        @Override
        void beforeSuite(TestDescriptor descriptor) {}

        @Override
        void afterSuite(TestDescriptor descriptor, TestResult result) {}

        @Override
        void beforeTest(TestDescriptor descriptor) {}

        @Override
        void afterTest(TestDescriptor descriptor, TestResult result) {
          if (isFileComparisonTestResult(result)) {
            TestEventLogger.writeLogTestEvent("afterTest", descriptor, null, result)
          }
        }
      }
    )
  }

  private static boolean isFileComparisonTestResult(TestResult testResult) {
    return 'com.intellij.rt.execution.junit.FileComparisonFailure' == testResult.exception?.class?.name
  }
}
// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
//file:noinspection GrPackage

gradle.taskGraph.whenReady { taskGraph ->
  taskGraph.allTasks.each { Task task ->
    if (task instanceof Test) {
      FileComparisonTestEventLogger.configureTestEventLogging(task)
      task.testLogging.showStandardStreams = false
    }
  }
}

// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
//file:noinspection GrPackage

//noinspection GrUnresolvedAccess
List<List<String>> classNames = [['com.intellij.rt.execution.junit.FileComparisonFailure','junit.framework.ComparisonFailure']]

gradle.taskGraph.whenReady { taskGraph ->
  taskGraph.allTasks.each { Task task ->
    if (task instanceof Test) {
      task.doFirst(new GradleDaemonClasspathEnhancer(logger, classNames))
    }
  }
}

class GradleDaemonClasspathEnhancer implements Action<Test> {

  private final Logger logger
  private final List<List<String>> classNames

  GradleDaemonClasspathEnhancer(Logger logger, List<List<String>> classNames) {
    this.logger = logger
    this.classNames = classNames
  }

  @Override
  void execute(Test task) {
    enhanceGradleDaemonClasspath(logger, task, classNames)
  }

  private static void enhanceGradleDaemonClasspath(Logger logger, Test task, List<List<String>> classNames) {
    try {
      def testClasspath = getTestClasspath(task)
      def classpath = classNames.collectMany(new LinkedHashSet()) {
        findJarsForClasses(testClasspath, it)
      }
      logger.debug("Test classpath:")
      for (def url : testClasspath) {
        logger.debug(url.toString())
      }
      logger.debug("Reduced classpath:")
      for (def url : classpath) {
        logger.debug(url.toString())
      }
      logger.debug("End of classpath")
      if (!classpath.isEmpty()) {
        def classLoader = getDaemonClassLoader()
        addClasspath(classLoader, classpath)
      }
    }
    catch (Throwable exception) {
      logger.error("Unable to enhance Gradle Daemon by $classNames", exception)
    }
  }

  private static URLClassLoader getDaemonClassLoader() {
    try {
      def daemonMainClass = Class.forName("org.gradle.launcher.daemon.bootstrap.DaemonMain")
      def classLoader = daemonMainClass.getClassLoader()
      if (classLoader instanceof URLClassLoader) {
        return classLoader
      }
      throw new IllegalStateException("Unsupported Gradle daemon class loader: $classLoader")
    }
    catch (ClassNotFoundException exception) {
      throw new IllegalStateException("Daemon class loader not found.", exception)
    }
  }

  private static List<URL> getTestClasspath(Test task) {
    return task.classpath.files.collect { it.toURI().toURL() }
  }

  /**
   * Finds reduced classpath for classes. The [classNames] parameter list
   * should contain expected class and all its dependencies. Therefore,
   * function returns empty list if any of classes wasn't found.
   */
  private static List<URL> findJarsForClasses(List<URL> classpath, List<String> classNames) {
    def foundClassNames = new HashSet<String>()
    def reducedClasspath = new ArrayList<URL>()
    for (def url : classpath) {
      new URLClassLoader([url] as URL[]).withCloseable { classLoader ->
        for (def className : classNames) {
          if (hasClass(classLoader, className)) {
            foundClassNames.add(className)
            reducedClasspath.add(url)
            break
          }
        }
      }
    }
    if (foundClassNames.size() != classNames.size()) {
      return []
    }
    return reducedClasspath
  }

  private static boolean hasClass(URLClassLoader classLoader, String className) {
    def classFile = className.replace(".", "/") + ".class"
    return classLoader.findResource(classFile) != null
  }

  private static void addClasspath(URLClassLoader classLoader, Iterable<URL> classpath) {
    for (def url : classpath) {
      //noinspection GroovyAccessibility
      classLoader.addURL(url)
    }
  }
}
//
//-- Generated by org.jetbrains.kotlin.idea.gradleJava.configuration.KotlinGradleCoroutineDebugProjectResolver
gradle.taskGraph.whenReady { TaskExecutionGraph taskGraph ->
    taskGraph.allTasks.each { Task task ->
        if (!(task instanceof Test || task instanceof JavaExec)) return
        FileCollection taskClasspath = task.classpath
        task.jvmArgumentProviders.add(new CommandLineArgumentProvider() {
            private static def VERSION_PATTERN = java.util.regex.Pattern.compile(/(\d+)\.(\d+)(\.(\d+))?.*/)
        
            @Override
            Iterable<String> asArguments() {
                List<String> emptyList = Collections.emptyList()
                if (System.getProperty("idea.debugger.dispatch.port") == null) return emptyList
                def kotlinxCoroutinesCoreJar = taskClasspath.find { it.name.startsWith("kotlinx-coroutines-core") && !it.name.contains("sources") }
                if (kotlinxCoroutinesCoreJar == null) return emptyList
                def results = (kotlinxCoroutinesCoreJar.getName() =~ /kotlinx-coroutines-core(\-jvm)?-(\d[\w\.\-]+)\.jar$/).findAll()
                if (results.isEmpty()) return emptyList
                String version = results.first()[2]
                def matcher = VERSION_PATTERN.matcher(version)
                try {
                    if (!matcher.matches()) return emptyList
                    int major = Integer.parseInt(matcher.group(1)) 
                    int minor = Integer.parseInt(matcher.group(2))
                    int patch = Integer.parseInt(matcher.group(4) ?: "0")
                    if (major < 1 || (major == 1 && (minor < 5 || (minor == 5 && patch < 1)))) return emptyList
                } catch (NumberFormatException ignored) {
                    return emptyList
                }
                return ["-javaagent:${kotlinxCoroutinesCoreJar?.absolutePath}", "-ea"]
            }
        })
    }
}
//